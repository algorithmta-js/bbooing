## 문제

n개의 음이 아닌 정수들이 있습니다. 이 정수들을 순서를 바꾸지 않고 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

1+1+1+1+1 = 3/
+1-1+1+1+1 = 3/
+1+1-1+1+1 = 3/
+1+1+1-1+1 = 3/
+1+1+1+1-1 = 3


사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
- 각 숫자는 1 이상 50 이하인 자연수입니다.
- 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

### 입출력 예

numbers
[1, 1, 1, 1, 1]
[4, 1, 2, 1]

target
3
4

return
5
2

## 풀이

1. 각 수 마다 + 혹은 -를 하여 **모든 경우의 수**를 체크하여 합한 값이 타겟 넘버가 되는지 알아야 한다.
2. 최단거리를 구하는 문제가 아니며, 각 경우마다 어떠한 타겟 값이 나오는지 알아야 하기 때문에 그래프 탐색 중에서도 **DFS** 방식을 선택하였고, 재귀 방식으로 문제를 풀고자 했다.
3. 이 문제를 단순히 손으로 그려서 푼다고 하면 배열의 각 수마다 + 혹은 -를 하고 그 모든 경우의 수를 다 합한 값이 타겟 값과 같은지 비교 하게 될 것이다. 따라서 **그래프의 노드를 각 경우를 합한 값**으로 설정 하고자 했다.
4.  ****각 인덱스를 모두 합한 마지막 노드에 도달하면, 그 노드의 값이 타겟값과 같은지 비교 한 후, 정답의 수를 세어 return 하고자 하였다.
5. 내가 풀이하고자 한 방식을 그래프로 그렸다. 위의 문제에서 두번째 방식에 대한 풀이 그래프를 그린것이다.
    
![스크린샷 2022-04-27 오후 5 44 49](https://user-images.githubusercontent.com/67372977/165480352-9b6471f9-2b61-4f7b-a892-e4661e840b46.png)

    
6. 마지막 노드에서 모든 경우의 수를 합한 값이 나오는데 그 중 4의 갯수는 2개 인것을 확인 할 수 있다.

위에서 설명한 풀이를 코드로 작성한 것은 다음과 같다.

```jsx
function solution(numbers, target) {
    var answer = 0;
    
    const dfs = (sum, idx) => {
        if(idx >= numbers.length){
            sum === target? (answer = answer + 1) : null;
            return;
        };
    
        dfs(sum + numbers[idx], idx+1);
        dfs(sum - numbers[idx], idx+1);
    }   
    
    dfs(0,0);
    
    return answer;
}
```
